<?xml version="1.0" encoding="UTF-8"?>
<minitel>
  

  <layers id="game" left="0" top="1" width="40" height="22">
  
    <!-- Définition du caractère mosaïque (bloc plein) -->
    <chardef name="charset1" type="mosaic">
      <!-- Caractère 0 : bloc plein 2x3 -->
      <char>
        <line>##</line>
        <line>##</line>
        <line>##</line>
      </char>
    </chardef>
  
    <!-- Map 0: Décor (bordures) en cyan -->
    <map>
      <row>#          #         Next:</row>
      <row repeat="19">#          #</row>
        <row><putchar index="0" repeat="12" /></row>
        <!--
        <row>############</row>
                -->
      <colormap>
        <row repeat="20">6          6</row>
        <row>666666666666</row>

      </colormap>
    </map>
    
    <!-- Map 1: Pièces posées (initialement vide) -->
    <map>
      <row>            </row>
      <row>            </row>
      <row>            </row>
      <row>            </row>
      <row>            </row>
      <row>            </row>
      <row>            </row>
      <row>            </row>
      <row>            </row>
      <row>            </row>
      <row>            </row>
      <row>            </row>
      <row>            </row>
      <row>            </row>
      <row>            </row>
      <row>            </row>
      <row>            </row>
      <row>            </row>
      <row>            </row>
      <row>            </row>
      <row>            </row>
    </map>
    
    <!-- Pièce active (4 blocs avec couleur) -->
    <spritedef id="block0" width="1" height="1" type="char">
      <sprite><line>#</line></sprite>
    </spritedef>
    <spritedef id="block1" width="1" height="1" type="char">
      <sprite><line>#</line></sprite>
    </spritedef>
    <spritedef id="block2" width="1" height="1" type="char">
      <sprite><line>#</line></sprite>
    </spritedef>
    <spritedef id="block3" width="1" height="1" type="char">
      <sprite><line>#</line></sprite>
    </spritedef>
    
    <!-- Prévisualisation pièce suivante -->
    <spritedef id="next0" width="1" height="1" type="char">
      <sprite><line>#</line></sprite>
    </spritedef>
    <spritedef id="next1" width="1" height="1" type="char">
      <sprite><line>#</line></sprite>
    </spritedef>
    <spritedef id="next2" width="1" height="1" type="char">
      <sprite><line>#</line></sprite>
    </spritedef>
    <spritedef id="next3" width="1" height="1" type="char">
      <sprite><line>#</line></sprite>
    </spritedef>
    
    <!-- Score et niveau -->
    <label id="score" x="14" y="6" width="14">Score: 0</label>
    <label id="level" x="14" y="8" width="14">Level: 1</label>
    <label id="lines" x="14" y="10" width="14">Lines: 0</label>
    <label id="gameover" x="14" y="14" width="14"></label>
    
    <!-- Contrôles -->
    <keypad action="LEFT" key="Q" event="moveLeft"/>
    <keypad action="RIGHT" key="D" event="moveRight"/>
    <keypad action="DOWN" key="S" event="moveDown"/>
    <keypad action="UP" key="Z" event="rotate"/>
    <keypad action="ACTION1" key=" " event="drop"/>
    
    <!-- Game loop -->
    <timer event="gameLoop" interval="500"></timer>
    
  </layers>
  
  <div left="0" top="23" width="40" height="1">
    <row>[Q]&lt; [D]&gt; [S]v [Z]Rot [SPACE]Drop</row>
  </div>
  
  <script>
    // Grille de jeu (10x20)
    var GRID_W = 10;
    var GRID_H = 20;
    var PIECES_MAP = 1;  // Index de la map des pièces posées
    
    // Couleurs des pièces (codes Minitel)
    // 0=noir, 1=rouge, 2=vert, 3=jaune, 4=bleu, 5=magenta, 6=cyan, 7=blanc
    var PIECE_COLORS = [
      6,  // I - Cyan
      3,  // O - Jaune
      5,  // T - Magenta
      2,  // S - Vert
      1,  // Z - Rouge
      4,  // J - Bleu
      7   // L - Blanc
    ];
    
    // Définition des pièces (rotations)
    // I, O, T, S, Z, J, L
    var PIECES = [
      // I
      [[[0,0],[1,0],[2,0],[3,0]], [[0,0],[0,1],[0,2],[0,3]]],
      // O
      [[[0,0],[1,0],[0,1],[1,1]]],
      // T
      [[[0,0],[1,0],[2,0],[1,1]], [[0,0],[0,1],[0,2],[1,1]], 
       [[1,0],[0,1],[1,1],[2,1]], [[1,0],[1,1],[1,2],[0,1]]],
      // S
      [[[1,0],[2,0],[0,1],[1,1]], [[0,0],[0,1],[1,1],[1,2]]],
      // Z
      [[[0,0],[1,0],[1,1],[2,1]], [[1,0],[0,1],[1,1],[0,2]]],
      // J
      [[[0,0],[0,1],[1,1],[2,1]], [[0,0],[1,0],[0,1],[0,2]],
       [[0,0],[1,0],[2,0],[2,1]], [[1,0],[1,1],[0,2],[1,2]]],
      // L
      [[[2,0],[0,1],[1,1],[2,1]], [[0,0],[0,1],[0,2],[1,2]],
       [[0,0],[1,0],[2,0],[0,1]], [[0,0],[1,0],[1,1],[1,2]]]
    ];
    
    // Caractère pour les pièces
    var PIECE_CHAR = '#';
    
    // État du jeu
    var currentPiece = 0;
    var currentRotation = 0;
    var pieceX = 4;
    var pieceY = 0;
    var nextPiece = 0;
    var score = 0;
    var level = 1;
    var linesCleared = 0;
    var gameOver = false;
    
    function getLayers() {
      return _currentLayers;
    }
    
    function randomPiece() {
      return Math.floor(Math.random() * 7);
    }
    
    function domReady() {
      var layers = getLayers();
      if (layers == null) return;
      
      // Initialiser les pièces
      currentPiece = randomPiece();
      nextPiece = randomPiece();
      pieceX = 4;
      pieceY = 0;
      currentRotation = 0;
      
      // Afficher la pièce courante et la suivante
      drawCurrentPiece(layers);
      drawNextPiece(layers);
    }
    
    function getBlocks() {
      var rotations = PIECES[currentPiece];
      var rot = currentRotation % rotations.length;
      return rotations[rot];
    }
    
    function getCurrentColor() {
      return PIECE_COLORS[currentPiece];
    }
    
    function getNextColor() {
      return PIECE_COLORS[nextPiece];
    }
    
    // Dessine la pièce active avec des sprites colorés
    function drawCurrentPiece(layers) {
      var blocks = getBlocks();
      var color = getCurrentColor();
      
      for (var i = 0; i < 4; i++) {
        var sprite = layers.getSprite("block" + i);
        if (sprite != null) {
          var bx = pieceX + blocks[i][0] + 1;  // +1 pour la bordure
          var by = pieceY + blocks[i][1];
          sprite.setColor(color);
          sprite.show(0);
          sprite.move(bx, by);
        }
      }
    }
    
    // Cache les sprites de la pièce active
    function hideCurrentPiece(layers) {
      for (var i = 0; i < 4; i++) {
        var sprite = layers.getSprite("block" + i);
        if (sprite != null) {
          sprite.hide();
        }
      }
    }
    
    // Cache les sprites de la pièce suivante
    function hideNextPiece(layers) {
      for (var i = 0; i < 4; i++) {
        var sprite = layers.getSprite("next" + i);
        if (sprite != null) {
          sprite.hide();
        }
      }
    }
    
    // Dessine la pièce suivante avec des sprites colorés
    function drawNextPiece(layers) {
      var rotations = PIECES[nextPiece];
      var blocks = rotations[0];
      var color = PIECE_COLORS[nextPiece];
      
      // Afficher chaque bloc avec sa couleur
      for (var i = 0; i < 4; i++) {
        var sprite = layers.getSprite("next" + i);
        if (sprite != null) {
          // D'abord déplacer à la nouvelle position
          var bx = 15 + blocks[i][0];
          var by = 2 + blocks[i][1];
          sprite.move(bx, by);
          // Puis afficher avec la couleur (show avec 2 params force la couleur)
          sprite.show(0, color);
        }
      }
    }
    
    function canMove(layers, dx, dy, newRotation) {
      var rotations = PIECES[currentPiece];
      var rot = newRotation % rotations.length;
      var blocks = rotations[rot];
      
      for (var i = 0; i < 4; i++) {
        var nx = pieceX + blocks[i][0] + dx;
        var ny = pieceY + blocks[i][1] + dy;
        
        // Vérifier les limites
        if (nx < 0 || nx >= GRID_W || ny >= GRID_H) {
          return false;
        }
        
        // Vérifier collision avec pièces posées (map 1)
        if (ny >= 0) {
          var c = layers.checkMapCollisionAt("block0", nx + 1, ny);
          if (c != 0 && c != 32) {  // 32 = espace
            return false;
          }
        }
      }
      return true;
    }
    
    // Verrouille la pièce dans la map des pièces posées
    function lockPiece(layers) {
      var blocks = getBlocks();
      var color = getCurrentColor();
      
      for (var i = 0; i < 4; i++) {
        var bx = pieceX + blocks[i][0];
        var by = pieceY + blocks[i][1];
        if (by >= 0 && by < GRID_H && bx >= 0 && bx < GRID_W) {
          // Écrire dans la map des pièces posées (map 1)
          layers.setMapChar(PIECES_MAP, bx + 1, by, PIECE_CHAR);
          layers.setMapColor(PIECES_MAP, bx + 1, by, color);
        }
      }
    }
    
    function isLineFull(layers, y) {
      for (var x = 0; x < GRID_W; x++) {
        var c = layers.checkMapCollisionAt("block0", x + 1, y);
        if (c == 0 || c == 32) {
          return false;
        }
      }
      return true;
    }
    
    function clearLines(layers) {
      var cleared = 0;
      
      for (var y = GRID_H - 1; y >= 0; y--) {
        if (isLineFull(layers, y)) {
          cleared++;
          // Décaler les lignes vers le bas (caractères + couleurs)
          layers.shiftMap(PIECES_MAP,"DOWN", 1, y);
          y++;  // Revérifier cette ligne
        }
      }
      
      if (cleared > 0) {
        linesCleared += cleared;
        // Score: 100, 300, 500, 800 pour 1, 2, 3, 4 lignes
        var points = [0, 100, 300, 500, 800];
        score += points[cleared] * level;
        
        // Niveau tous les 10 lignes
        var newLevel = Math.floor(linesCleared / 10) + 1;
        if (newLevel > level) {
          level = newLevel;
        }
        
        layers.setText("score", "Score: " + score);
        layers.setText("level", "Level: " + level);
        layers.setText("lines", "Lines: " + linesCleared);
        layers.beep();
      }
    }
    
    function spawnNewPiece(layers) {
      currentPiece = nextPiece;
      nextPiece = randomPiece();
      pieceX = 4;
      pieceY = 0;
      currentRotation = 0;
      
      // Vérifier game over
      if (!canMove(layers, 0, 0, currentRotation)) {
        gameOver = true;
        // Afficher GAME OVER sur un label dédié
        layers.setText("gameover", "GAME OVER!");
        layers.beep();
        return;
      }
      
      drawCurrentPiece(layers);
      // Effacer l'ancienne pièce suivante avant de dessiner la nouvelle
      hideNextPiece(layers);
      drawNextPiece(layers);
    }
    
    function moveLeft() {
      if (gameOver) return;
      var layers = getLayers();
      if (layers == null) return;
      
      if (canMove(layers, -1, 0, currentRotation)) {
        hideCurrentPiece(layers);
        pieceX--;
        drawCurrentPiece(layers);
      }
    }
    
    function moveRight() {
      if (gameOver) return;
      var layers = getLayers();
      if (layers == null) return;
      
      if (canMove(layers, 1, 0, currentRotation)) {
        hideCurrentPiece(layers);
        pieceX++;
        drawCurrentPiece(layers);
      }
    }
    
    function moveDown() {
      if (gameOver) return;
      var layers = getLayers();
      if (layers == null) return;
      
      if (canMove(layers, 0, 1, currentRotation)) {
        hideCurrentPiece(layers);
        pieceY++;
        drawCurrentPiece(layers);
      } else {
        // Verrouiller la pièce
        hideCurrentPiece(layers);
        lockPiece(layers);
        clearLines(layers);
        spawnNewPiece(layers);
      }
    }
    
    function rotate() {
      if (gameOver) return;
      var layers = getLayers();
      if (layers == null) return;
      
      var newRotation = currentRotation + 1;
      if (canMove(layers, 0, 0, newRotation)) {
        hideCurrentPiece(layers);
        currentRotation = newRotation;
        drawCurrentPiece(layers);
      }
    }
    
    function drop() {
      if (gameOver) return;
      var layers = getLayers();
      if (layers == null) return;
      
      hideCurrentPiece(layers);
      while (canMove(layers, 0, 1, currentRotation)) {
        pieceY++;
      }
      
      // Verrouiller immédiatement
      lockPiece(layers);
      clearLines(layers);
      spawnNewPiece(layers);
    }
    
    function gameLoop() {
      if (gameOver) return;
      
      var layers = getLayers();
      if (layers == null) return;
      
      // Descente automatique
      moveDown();
    }
  </script>
</minitel>
